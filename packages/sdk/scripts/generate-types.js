#!/usr/bin/env node

/**
 * @file generate-types.js
 * @description Generates TypeScript bindings from Solidity contract ABIs
 * @usage node packages/sdk/scripts/generate-types.js
 */

const fs = require('fs');
const path = require('path');

const CONTRACTS_OUT_DIR = path.join(__dirname, '../../contracts/out');
const SDK_SRC_DIR = path.join(__dirname, '../src');
const GENERATED_FILE = path.join(SDK_SRC_DIR, 'contracts.ts');

/**
 * Find all JSON ABI files in the contracts out directory
 */
function findAbiFiles(dir) {
  const abiFiles = [];
  
  function traverse(currentDir) {
    try {
      const entries = fs.readdirSync(currentDir, { withFileTypes: true });
      
      for (const entry of entries) {
        const fullPath = path.join(currentDir, entry.name);
        
        if (entry.isDirectory()) {
          traverse(fullPath);
        } else if (entry.isFile() && entry.name.endsWith('.json')) {
          // Only include contract JSON files (not build info)
          if (!currentDir.includes('build-info')) {
            abiFiles.push(fullPath);
          }
        }
      }
    } catch (error) {
      // Directory doesn't exist or can't be read
    }
  }
  
  traverse(dir);
  return abiFiles;
}

/**
 * Extract contract name from file path
 */
function getContractName(filePath) {
  const basename = path.basename(filePath, '.json');
  // Remove .sol extension if present
  return basename.replace('.sol', '');
}

/**
 * Load and parse ABI from JSON file
 */
function loadAbi(filePath) {
  try {
    const content = fs.readFileSync(filePath, 'utf8');
    const json = JSON.parse(content);
    
    // Foundry output has abi property
    if (json.abi && Array.isArray(json.abi)) {
      return {
        abi: json.abi,
        bytecode: json.bytecode?.object || json.bytecode || '',
      };
    }
    
    return null;
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}:`, error.message);
    return null;
  }
}

/**
 * Generate TypeScript file with all ABIs
 */
function generateTypesFile(contracts) {
  const timestamp = new Date().toISOString();
  
  let output = `// GENERATED FILE - DO NOT EDIT
// Generated at: ${timestamp}
// Generated by: packages/sdk/scripts/generate-types.js

/**
 * Contract ABIs and metadata for YesNo.Win prediction markets
 * @packageDocumentation
 */

`;

  // Generate type for contract names
  const contractNames = Object.keys(contracts);
  output += `export type ContractName = ${contractNames.map(name => `'${name}'`).join(' | ')};\n\n`;

  // Generate interface for contract data
  output += `export interface ContractData {
  abi: any[];
  bytecode: string;
}\n\n`;

  // Export individual ABIs as constants
  for (const [name, data] of Object.entries(contracts)) {
    output += `/**
 * ${name} contract ABI
 */
export const ${name}ABI = ${JSON.stringify(data.abi, null, 2)} as const;

`;

    if (data.bytecode) {
      output += `/**
 * ${name} contract bytecode
 */
export const ${name}Bytecode = "${data.bytecode}";

`;
    }
  }

  // Export contracts object
  output += `/**
 * All contract ABIs and bytecode
 */
export const contracts: Record<ContractName, ContractData> = {
`;

  for (const [name, data] of Object.entries(contracts)) {
    output += `  ${name}: {
    abi: ${name}ABI,
    bytecode: ${data.bytecode ? `${name}Bytecode` : '""'},
  },
`;
  }

  output += `} as const;\n\n`;

  // Export helper function
  output += `/**
 * Get contract ABI and bytecode by name
 * @param name - Contract name
 * @returns Contract ABI and bytecode
 */
export function getContract(name: ContractName): ContractData {
  return contracts[name];
}

/**
 * Get contract ABI by name
 * @param name - Contract name
 * @returns Contract ABI
 */
export function getABI(name: ContractName): any[] {
  return contracts[name].abi;
}

/**
 * Check if a contract exists
 * @param name - Contract name
 * @returns True if contract exists
 */
export function hasContract(name: string): name is ContractName {
  return name in contracts;
}

/**
 * Get all contract names
 * @returns Array of contract names
 */
export function getContractNames(): ContractName[] {
  return Object.keys(contracts) as ContractName[];
}
`;

  return output;
}

/**
 * Main execution
 */
function main() {
  console.log('üî® Generating TypeScript bindings from contract ABIs...\n');

  // Check if contracts are built
  if (!fs.existsSync(CONTRACTS_OUT_DIR)) {
    console.error('‚ùå Error: Contracts not built. Run `pnpm build:contracts` first.');
    process.exit(1);
  }

  // Find all ABI files
  console.log(`üìÅ Searching for ABIs in: ${CONTRACTS_OUT_DIR}`);
  const abiFiles = findAbiFiles(CONTRACTS_OUT_DIR);
  console.log(`   Found ${abiFiles.length} JSON files\n`);

  // Load contracts we care about (exclude test mocks and libraries)
  const targetContracts = ['Market', 'MarketFactory', 'OutcomeToken', 'OracleAdapter', 'MockUSDC'];
  const contracts = {};

  for (const filePath of abiFiles) {
    const contractName = getContractName(filePath);
    
    // Only include target contracts
    if (targetContracts.includes(contractName)) {
      const data = loadAbi(filePath);
      
      if (data && data.abi.length > 0) {
        contracts[contractName] = data;
        console.log(`‚úÖ Loaded: ${contractName}`);
        console.log(`   ABI entries: ${data.abi.length}`);
        console.log(`   Bytecode: ${data.bytecode ? 'Yes' : 'No'}`);
      }
    }
  }

  console.log(`\nüìù Generating TypeScript file with ${Object.keys(contracts).length} contracts...`);

  // Ensure SDK src directory exists
  if (!fs.existsSync(SDK_SRC_DIR)) {
    fs.mkdirSync(SDK_SRC_DIR, { recursive: true });
  }

  // Generate and write types file
  const typesContent = generateTypesFile(contracts);
  fs.writeFileSync(GENERATED_FILE, typesContent, 'utf8');

  console.log(`‚úÖ Generated: ${GENERATED_FILE}`);
  console.log(`   File size: ${(typesContent.length / 1024).toFixed(2)} KB`);
  console.log(`\nüéâ Type generation complete!`);
  console.log(`\nYou can now import contracts in your code:`);
  console.log(`  import { MarketABI, getContract } from '@yesno-win/sdk';`);
}

// Run if called directly
if (require.main === module) {
  try {
    main();
  } catch (error) {
    console.error('\n‚ùå Error:', error.message);
    if (error.stack) {
      console.error('\nStack trace:', error.stack);
    }
    process.exit(1);
  }
}

module.exports = { main };
